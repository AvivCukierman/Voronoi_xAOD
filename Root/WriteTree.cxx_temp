#include <EventLoop/Job.h>
#include <EventLoop/StatusCode.h>
#include <EventLoop/Worker.h>
#include "EventLoop/OutputStream.h"
#include <MyAnalysis/WriteTree.h>

// EDM includes
#include "xAODEventInfo/EventInfo.h"
#include "xAODJet/JetContainer.h"
#include "xAODMuon/MuonContainer.h"
#include "xAODEgamma/ElectronContainer.h"
#include "xAODEgamma/PhotonContainer.h"
#include "xAODTau/TauJetContainer.h"
#include "xAODTruth/TruthParticleContainer.h"
#include "xAODMissingET/MissingETContainer.h"
//#include "xAODBTaggingEfficiency/BTaggingEfficiencyTool.h"
#include "xAODBTagging/BTagging.h"

// Infrastructure includes
#include "xAODRootAccess/Init.h"
#include "xAODBase/IParticleContainer.h"
#include "AthLinks/ElementLink.h"

// xAH includes
#include "xAODAnaHelpers/HelperFunctions.h"
//#include "xAODAnaHelpers/tools/ReturnCheck.h"

// root includes
#include <TFile.h>

// c++ includes
#include <set>
#include <stdlib.h>

namespace HF = HelperFunctions;
// this is needed to distribute the algorithm to the workers
ClassImp(WriteTree)
WriteTree :: WriteTree () :
  m_tree(new TTree("oTree", "tree")),
  m_eventNumber(-999.0),
{}

EL::StatusCode WriteTree :: setupJob (EL::Job& job)
{
  job.useXAOD();
  xAOD::Init("WriteTree").ignore();

  /* https://twiki.cern.ch/twiki/bin/viewauth/AtlasProtected/EventLoop#Creating_output_n_tuples */
  // output file for optimization tree
  EL::OutputStream out ("outTree");
  job.outputAdd (out);

  return EL::StatusCode::SUCCESS;
}

EL::StatusCode WriteTree :: histInitialize () { return EL::StatusCode::SUCCESS; }
EL::StatusCode WriteTree :: fileExecute () { return EL::StatusCode::SUCCESS; }
EL::StatusCode WriteTree :: changeInput (bool /*firstFile*/) { return EL::StatusCode::SUCCESS; }

EL::StatusCode WriteTree :: initialize () {
  // assign m_event and m_store
  m_event = wk()->xaodEvent();
  m_store = wk()->xaodStore();

  TFile *file = wk()->getOutputFile ("outTree");
  m_tree->SetDirectory (file);

  m_tree->Branch ("event_number",              &m_eventNumber, "event_number/I");

  return EL::StatusCode::SUCCESS;
}

EL::StatusCode WriteTree :: execute ()
{
  if(m_debug) Info("execute()", "Calling execute...");
  const xAOD::EventInfo*                eventInfo     (nullptr);

  // start grabbing all the containers that we can
  ANA_CHECK(HF::retrieve(eventInfo,    m_eventInfo,        m_event, m_store, m_debug));

  // compute variables for optimization
  m_eventNumber = eventInfo->eventNumber();

  // fill in all variables
  m_tree->Fill();

  return EL::StatusCode::SUCCESS;
}

EL::StatusCode WriteTree :: postExecute () { return EL::StatusCode::SUCCESS; }

EL::StatusCode WriteTree :: finalize () {
  return EL::StatusCode::SUCCESS;
}

EL::StatusCode WriteTree :: histFinalize () { return EL::StatusCode::SUCCESS; }
